const graph = {
    0:[1,2,3],
    1:[4,5],
    2:[],
    3:[],
    4:[6],
    5:[],
    6:[]
}
function DFS(graph, node, visited = []) {
    if (visited.indexOf(node) === -1) {
        visited.push(node);
				// 첫번재 함수호출에서 visited에 [0]이들어간다
        for (let neighbor of graph[node]) {
            // 각각 0에 있는 1,2,3이 순차적으로 실행됨 visited는 [0]
            // DFS(graph, 1, [0])
            // DFS(graph, 2, [0,1,4,6,5])
            // DFS(graph, 3, [0,1,4,6,5,2]) 이렇게 들어가게됨!
            DFS(graph, neighbor, visited);
        }
    }
    return visited;
}
console.time();
const result = DFS(graph,0)
console.log(result)//[0, 3, 2, 1, 5, 4, 6]
console.timeEnd();

// DFS(graph, neighbor, [0]);
// DFS(graph, 1, [0]);
// DFS(graph, 4, [0,1]);
// DFS(graph, 6, [0,1,4]);
// DFS(graph, 5, [0,1,4,6]);
// DFS(graph, 2, [0,1,4,6,5]);
// DFS(graph, 3, [0,1,4,6,5,2]);
// [0,1,4,6,5,2,3]

// 첫번째 시작 -> 시작노드가 0
// 방문목록에 0을추가 
// 0 - > 이때 방문목록이 [0]
// 그리고 0노드의 이웃을 방문한다. -> 1,2,3 순서로 방문하게됨
// 1먼저 들어감 -> 여기서 반복문 1,2,3  중에 1시작
// dfs(graph, 1, [0])
// 1 노드에는 [4,5]가 있었습니다.
// 방문목록에 1추가
// 이때 방문 목록이 [0,1]
// 4먼저 들어가자!-> 여기서 반복문 4,5 중에 4를 시작한것임
// dfs(graph, 4, [0,1])
// 방문목록에 [0,1,4]
// 4에는 [6]이 있습니다.
// 6방문
// dfs(graph, 6, [0,1,4,6])
// 방문 목록에 6추가
// 방문목록에 [0,1,4,6]
// 6에는 인접한 노드가 없음
// 이제 return이 이루어짐
// dfs(dsf(dsf(dsf())))
// 이제 여기서 반복문 4,5 중에 5를 시작할것임
// dfs(graph, 5, [0,1,4,6])
// 방문할 노드 없음
// 방문목록에 [0,1,4,6,5]
// 여기서 반복문 1,2,3  중에 2시작
// dfs(graph, 2, [0,1,4,6,5])
// 방문목록에 [0,1,4,6,5,2]
// 방문할 노드 없음
// 여기서 반복문 1,2,3  중에 3시작
// dfs(graph, 3, [0,1,4,6,5,2])
// 방문목록에 [0,1,4,6,5,2,3]
// 방문할 노드 없음
// 끝!